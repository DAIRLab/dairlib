admm_iter: 3
rho: 0.1
rho_scale: 2
num_threads: 6
delta_option: 1
# options are 'MIQP' or 'QP'
projection_type: 'QP'
# options are 'stewart_and_trinkle' or 'anitescu
contact_model: 'anitescu'

mu: 0.4
mu_plate: 0.4
dt: 0.05
solve_dt: 0.05
num_friction_directions: 2
num_contacts: 3
N: 5

# matrix scaling
w_Q: 5
w_R: 0
# Penalty on all decision variables, assuming scalar
w_G: 0.5
# Penalty on all decision variables, assuming scalar
w_U: 1

# n_lambda = 2 * n_contacts + 2 * n_contacts * num_friction_directions
# size = n_x ( 7 + 3 + 6 + 3 ) + n_lambda (2 * 3  + 2 * 3 * 2) + n_u (3) = 40 for stewart and trinkle
# size = n_x ( 7 + 3 + 6 + 3 ) + n_lambda (2 * 3 * 2) + n_u (3) = 34 for anitescu
#g_size: 40
#u_size: 40
g_size: 34
u_size: 34
# State Tracking Error, assuming diagonal
q_vector: [10, 10, 5000, 0, 0, 0, 0, 10000, 10000, 10000,
           0, 0, 0, 0, 0, 0, 1, 1, 1]
# Penalty on all decision variables
#g_vector: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
#           1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
g_vector: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
           1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
# Penalty on all decision variables
#u_vector: [100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 1,
#           1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
u_vector: [100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 1,
           1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
# Penalty on efforts, assuming diagonal
r_vector: [1, 1, 1]

q_des_vector: [0.55, 0.00, 0.4, 1, 0, 0, 0, 0.55, 0.00, 0.42]
v_des_vector: [0, 0, 0, 0, 0, 0, 0, 0, 0]

neutral_position: [0.55, 0, 0.40]
x_scale: 0.1
y_scale: 0.1
z_scale: 0.1